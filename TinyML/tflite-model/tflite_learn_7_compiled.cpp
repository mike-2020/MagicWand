/*
 * Copyright (c) 2024 EdgeImpulse Inc.
 *
 * Generated by Edge Impulse and licensed under the applicable Edge Impulse
 * Terms of Service. Community and Professional Terms of Service
 * (https://docs.edgeimpulse.com/page/terms-of-service) or Enterprise Terms of
 * Service (https://docs.edgeimpulse.com/page/enterprise-terms-of-service),
 * according to your product plan subscription (the “License”).
 *
 * This software, documentation and other associated files (collectively referred
 * to as the “Software”) is a single SDK variation generated by the Edge Impulse
 * platform and requires an active paid Edge Impulse subscription to use this
 * Software for any purpose.
 *
 * You may NOT use this Software unless you have an active Edge Impulse subscription
 * that meets the eligibility requirements for the applicable License, subject to
 * your full and continued compliance with the terms and conditions of the License,
 * including without limitation any usage restrictions under the applicable License.
 *
 * If you do not have an active Edge Impulse product plan subscription, or if use
 * of this Software exceeds the usage limitations of your Edge Impulse product plan
 * subscription, you are not permitted to use this Software and must immediately
 * delete and erase all copies of this Software within your control or possession.
 * Edge Impulse reserves all rights and remedies available to enforce its rights.
 *
 * Unless required by applicable law or agreed to in writing, the Software is
 * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied. See the License for the specific language governing
 * permissions, disclaimers and limitations under the License.
 */
// Generated on: 07.07.2024 07:11:40

#include <stdio.h>
#include <stdlib.h>
#include "edge-impulse-sdk/tensorflow/lite/c/builtin_op_data.h"
#include "edge-impulse-sdk/tensorflow/lite/c/common.h"
#include "edge-impulse-sdk/tensorflow/lite/micro/micro_mutable_op_resolver.h"
#include "edge-impulse-sdk/porting/ei_classifier_porting.h"

#if EI_CLASSIFIER_PRINT_STATE
#if defined(__cplusplus) && EI_C_LINKAGE == 1
extern "C" {
    extern void ei_printf(const char *format, ...);
}
#else
extern void ei_printf(const char *format, ...);
#endif
#endif

#if defined __GNUC__
#define ALIGN(X) __attribute__((aligned(X)))
#elif defined _MSC_VER
#define ALIGN(X) __declspec(align(X))
#elif defined __TASKING__
#define ALIGN(X) __align(X)
#elif defined __ICCARM__
#define ALIGN(x) __attribute__((aligned(x)))
#endif

#ifndef EI_MAX_SCRATCH_BUFFER_COUNT
#ifndef CONFIG_IDF_TARGET_ESP32S3
#define EI_MAX_SCRATCH_BUFFER_COUNT 4
#else
#define EI_MAX_SCRATCH_BUFFER_COUNT 4
#endif // CONFIG_IDF_TARGET_ESP32S3
#endif // EI_MAX_SCRATCH_BUFFER_COUNT

#ifndef EI_MAX_OVERFLOW_BUFFER_COUNT
#define EI_MAX_OVERFLOW_BUFFER_COUNT 10
#endif // EI_MAX_OVERFLOW_BUFFER_COUNT

using namespace tflite;
using namespace tflite::ops;
using namespace tflite::ops::micro;

namespace {

#if defined(EI_CLASSIFIER_ALLOCATION_STATIC_HIMAX) || defined(EI_CLASSIFIER_ALLOCATION_STATIC_HIMAX_GNU)
constexpr int kTensorArenaSize = 1568;
#else
constexpr int kTensorArenaSize = 544;
#endif

#if defined(EI_CLASSIFIER_ALLOCATION_STATIC)
uint8_t tensor_arena[kTensorArenaSize] ALIGN(16);
#elif defined(EI_CLASSIFIER_ALLOCATION_STATIC_HIMAX)
#pragma Bss(".tensor_arena")
uint8_t tensor_arena[kTensorArenaSize] ALIGN(16);
#pragma Bss()
#elif defined(EI_CLASSIFIER_ALLOCATION_STATIC_HIMAX_GNU)
uint8_t tensor_arena[kTensorArenaSize] ALIGN(16) __attribute__((section(".tensor_arena")));
#else
#define EI_CLASSIFIER_ALLOCATION_HEAP 1
uint8_t* tensor_arena = NULL;
#endif

static uint8_t* tensor_boundary;
static uint8_t* current_location;

template <int SZ, class T> struct TfArray {
  int sz; T elem[SZ];
};

enum used_operators_e {
  OP_FULLY_CONNECTED, OP_SOFTMAX,  OP_LAST
};

struct TensorInfo_t { // subset of TfLiteTensor used for initialization from constant memory
  TfLiteAllocationType allocation_type;
  void* data;
  TfLiteIntArray* dims;
  size_t bytes;
};

typedef struct {
  TfLiteTensor tensor;
  int16_t index;
} TfLiteTensorWithIndex;

typedef struct {
  TfLiteEvalTensor tensor;
  int16_t index;
} TfLiteEvalTensorWithIndex;

TfLiteContext ctx{};
static const int MAX_TFL_TENSOR_COUNT = 4;
static TfLiteTensorWithIndex tflTensors[MAX_TFL_TENSOR_COUNT];
static const int MAX_TFL_EVAL_COUNT = 4;
static TfLiteEvalTensorWithIndex tflEvalTensors[MAX_TFL_EVAL_COUNT];
TfLiteRegistration registrations[OP_LAST];

namespace g0 {
const TfArray<2, int> tensor_dimension0 = { 2, { 1,33 } };
const ALIGN(16) float tensor_data1[10] = { -0.016724169254302979, 0, -0.10302416235208511, -0.01342194527387619, 0.063430562615394592, 0.15754327178001404, 0.082387916743755341, 0.059783264994621277, -0.080618605017662048, -0.11429712921380997, };
const TfArray<1, int> tensor_dimension1 = { 1, { 10 } };
const ALIGN(16) float tensor_data2[20] = { 0.1410936564207077, 0.11167930066585541, -0.11462375521659851, -0.11724483966827393, 0.15381509065628052, -0.035595152527093887, -0.0093055693432688713, -0.053402867168188095, -0.027476072311401367, 0.039132092148065567, 0.059347141534090042, -0.018213091418147087, 0, 0.11972340196371078, 0, -0.0160637516528368, 0.11710131913423538, 0.2296769767999649, 0, 0.049190796911716461, };
const TfArray<1, int> tensor_dimension2 = { 1, { 20 } };
const ALIGN(16) float tensor_data3[4] = { -0.12489395588636398, 0.1855304092168808, -0.059189267456531525, 0.0092749372124671936, };
const TfArray<1, int> tensor_dimension3 = { 1, { 4 } };
const ALIGN(16) float tensor_data4[20*33] = { 
  0.20837992429733276, 0.012484184466302395, 0.1188015416264534, 0.38490983843803406, 0.26467561721801758, 0.29882955551147461, 0.15006022155284882, 0.13011682033538818, 0.18257172405719757, -0.080256380140781403, 0.051849197596311569, 0.041404392570257187, -0.10417197644710541, -0.29164788126945496, -0.031918928027153015, 0.303902268409729, 0.060402549803256989, 0.20913699269294739, -0.22369775176048279, -0.25210988521575928, 0.066190838813781738, -0.17105038464069366, 0.2578217089176178, 0.070658192038536072, -0.37665989995002747, 0.29653537273406982, -0.15650147199630737, -0.09914928674697876, -0.26783737540245056, -0.29994174838066101, -0.088859289884567261, -0.052012667059898376, 0.12753596901893616, 
  -0.33283048868179321, 0.0071490569971501827, 0.24462875723838806, 0.067684531211853027, -0.092279121279716492, 0.012796097435057163, 0.054560679942369461, 0.056713201105594635, 0.069358006119728088, 0.42115926742553711, -0.29625114798545837, 0.008087698370218277, 0.13136254251003265, -0.066216543316841125, 0.17983740568161011, -0.21866242587566376, 0.14729695022106171, 0.08299659937620163, 0.13991713523864746, -0.34005960822105408, -0.21661831438541412, -0.14210818707942963, 0.26559296250343323, -0.039741270244121552, 0.10647515207529068, 0.20628248155117035, -0.036203041672706604, 0.26811730861663818, -0.040657155215740204, -0.30331605672836304, -0.16436350345611572, 0.23150080442428589, 0.25928637385368347, 
  0.1664707213640213, -0.043639801442623138, -0.30674520134925842, -0.22240415215492249, 0.13636277616024017, -0.092083483934402466, 0.28355994820594788, 0.2191912978887558, 0.37641474604606628, -0.16872523725032806, -0.18373569846153259, 0.26168310642242432, -0.33613473176956177, 0.361928790807724, -0.13898774981498718, 0.30689427256584167, 0.20932470262050629, 0.27302029728889465, 0.2782442569732666, 0.3495175838470459, 0.58730345964431763, -0.14585110545158386, 0.26222908496856689, -0.23693384230136871, 0.19005016982555389, -0.097115673124790192, 0.32189026474952698, 0.13248512148857117, -0.16450652480125427, -0.14109693467617035, 0.035130217671394348, 0.38587719202041626, 0.27542325854301453, 
  -0.26759931445121765, 0.14579696953296661, -0.14808779954910278, 0.17423726618289948, -0.038650535047054291, 0.23210839927196503, 0.021587813273072243, 0.32334625720977783, 0.26413798332214355, -0.42360848188400269, 0.36835730075836182, 0.45265212655067444, 0.046214926987886429, 0.38604670763015747, 0.16753421723842621, -0.030720861628651619, -0.14688682556152344, -0.084825702011585236, 0.35213756561279297, 0.40529283881187439, -0.00042204611236229539, 0.27850207686424255, -0.15924191474914551, -0.12918701767921448, 0.32904767990112305, 0.15906837582588196, -0.25780439376831055, 0.23812703788280487, 0.22610332071781158, 0.32445555925369263, 0.04248230904340744, 0.26660549640655518, 0.34978973865509033, 
  0.46100267767906189, 0.071482650935649872, 0.22960923612117767, -0.17802013456821442, -0.22710001468658447, -0.24004964530467987, 0.24143756926059723, 0.27239313721656799, -0.080895565450191498, 0.37702691555023193, -0.036566648632287979, -0.12264706939458847, -0.21974979341030121, -0.34040331840515137, -0.19351252913475037, 0.083788365125656128, 0.1150413304567337, 0.11465243995189667, -0.18383558094501495, -0.25928333401679993, -0.31238555908203125, 0.13161027431488037, -0.021080661565065384, -0.059958286583423615, -0.13312649726867676, 0.10721493512392044, 0.23523400723934174, 0.26974767446517944, -0.12655074894428253, -0.17072774469852448, -0.022975428029894829, -0.2796415388584137, 0.32376712560653687, 
  -0.12470368295907974, 0.20943668484687805, 0.032946344465017319, -0.046444427222013474, -0.14304649829864502, -0.27023518085479736, 0.024206062778830528, 0.31981521844863892, -0.14173249900341034, 0.064967922866344452, -0.32359215617179871, -0.15299686789512634, -0.35749387741088867, 0.12248788774013519, 0.022605277597904205, -0.041917826980352402, -0.30445528030395508, 0.091030023992061615, -0.13784247636795044, 0.0032708293292671442, -0.29150170087814331, -0.30493494868278503, -0.066933192312717438, -0.20034278929233551, 0.20867460966110229, -0.11714930087327957, 0.051309093832969666, -0.069753222167491913, -0.20974352955818176, 0.28673642873764038, -0.089887067675590515, -0.070281937718391418, 0.22321528196334839, 
  0.14768627285957336, -0.1032608225941658, -0.13240841031074524, -0.17039677500724792, -0.20519262552261353, -0.32568609714508057, -0.10923339426517487, 0.22161464393138885, -0.12991777062416077, 0.013484134338796139, -0.023899832740426064, -0.035097025334835052, -0.0039842245168983936, 0.18528327345848083, 0.12509560585021973, -0.062072742730379105, -0.14097084105014801, -0.17594423890113831, 0.31225857138633728, 0.24973821640014648, -0.16787567734718323, 0.056420344859361649, -0.15814860165119171, 0.21044695377349854, -0.1403951495885849, -0.035492554306983948, 0.32000496983528137, -0.29113268852233887, 0.25311362743377686, 0.0708819180727005, 0.21910631656646729, -0.32390987873077393, -0.0023183722514659166, 
  0.21438443660736084, -0.3115861713886261, 0.079554401338100433, 0.27911484241485596, 0.27749979496002197, 0.13153332471847534, 0.14510886371135712, 0.10464458912611008, -0.061246909201145172, 0.15208359062671661, -0.0029713804833590984, 0.46716552972793579, -0.15945059061050415, 0.27247336506843567, -0.17374822497367859, -0.24952806532382965, -0.00061831617495045066, -0.081699363887310028, -0.0055976854637265205, 0.46089997887611389, 0.4714902937412262, -0.083129726350307465, -0.1254153698682785, 0.029799342155456543, 0.017616912722587585, 0.31927973031997681, -0.058856785297393799, 0.12232223153114319, -0.28498288989067078, 0.031366109848022461, 0.204759880900383, 0.43417477607727051, 0.14487622678279877, 
  0.11640211194753647, 0.25373753905296326, 0.13971732556819916, -0.12567003071308136, -0.37480583786964417, 0.1338685154914856, -0.10804414004087448, -0.27371975779533386, -0.04388779029250145, -0.13881395757198334, 0.013561398722231388, 0.10978461056947708, 0.073178678750991821, -0.2195594310760498, -0.0026997607201337814, -0.23570039868354797, 0.074697263538837433, -0.23359732329845428, 0.29035523533821106, -0.011484277434647083, 0.20808501541614532, 0.12948571145534515, 0.25174352526664734, 0.060685090720653534, 0.14278712868690491, 0.24301007390022278, 0.14789889752864838, -0.025262733921408653, 0.21014711260795593, -0.28397008776664734, 0.10225092619657516, -0.35349813103675842, -0.080681584775447845, 
  -0.49435952305793762, 0.23618850111961365, -0.50664734840393066, 0.04833516851067543, -0.13611209392547607, 0.18154940009117126, -0.24343268573284149, -0.28528597950935364, -0.4403403103351593, -0.45414873957633972, -0.50599712133407593, -0.12875813245773315, -0.18586347997188568, 0.02727498859167099, -0.13897605240345001, 0.3863753080368042, 0.009350496344268322, 0.28345149755477905, 0.10448941588401794, -0.14707383513450623, 0.07883964478969574, 0.33065319061279297, 0.14048556983470917, 0.42895829677581787, 0.42915552854537964, 0.14938078820705414, 0.16352207958698273, 0.046477191150188446, 0.10846565663814545, 0.1157001331448555, -0.014308536425232887, -0.007822415791451931, -0.17816717922687531, 
  0.53601127862930298, 0.16741438210010529, 0.36122789978981018, -0.17708697915077209, -0.060602243989706039, 0.040618240833282471, 0.31680670380592346, 0.41877993941307068, 0.10696190595626831, 0.25034070014953613, -0.10928495228290558, 0.2928963303565979, 0.33167350292205811, -0.054549608379602432, 0.23364022374153137, -0.05057891458272934, 0.069341011345386505, 0.071902148425579071, 0.27079358696937561, 0.24474745988845825, -0.1477818638086319, 0.30894199013710022, -0.24856995046138763, 0.38015025854110718, 0.35640355944633484, -0.022707736119627953, -0.042426109313964844, -0.0085833687335252762, 0.24863371253013611, 0.22804053127765656, -0.20911365747451782, -0.24685671925544739, -0.24743632972240448, 
  0.078247427940368652, 0.17341262102127075, 0.42065289616584778, -0.016708105802536011, -0.15630848705768585, -0.15855927765369415, 0.44381901621818542, 0.005959030706435442, 0.37143298983573914, 0.0024461878929287195, 0.41692528128623962, 0.48931452631950378, 0.32605704665184021, 0.48089063167572021, -0.054499659687280655, 0.27760753035545349, -0.021741000935435295, -0.0068101473152637482, 0.51436662673950195, 0.17511628568172455, 0.13446137309074402, 0.084823824465274811, 0.37442836165428162, 0.098705030977725983, 0.20654314756393433, 0.12527003884315491, 0.29440760612487793, 0.18665798008441925, 0.34409117698669434, 0.20215602219104767, 0.10605918616056442, 0.029895776882767677, 0.064620651304721832, 
  -0.15333175659179688, -0.31888249516487122, 0.003483206033706665, -0.10710349678993225, 0.20230969786643982, -0.28809493780136108, -0.19926528632640839, -0.32444664835929871, -0.26995581388473511, 0.15992158651351929, -0.0774574875831604, -0.309194415807724, 0.08193930983543396, 0.17778095602989197, -0.11592318117618561, 0.2457142174243927, 0.042544275522232056, -0.11290477216243744, 0.27710404992103577, -0.09085005521774292, 0.15609288215637207, 0.18736222386360168, -0.20915237069129944, 0.20810458064079285, 0.16715326905250549, -0.10596510767936707, 0.023357003927230835, -0.16096805036067963, 0.27912434935569763, -0.088085949420928955, -0.14214174449443817, 0.079108059406280518, -0.32298552989959717, 
  -0.050132311880588531, -0.35217523574829102, -0.30925971269607544, -0.15840250253677368, 0.17941692471504211, 0.19048386812210083, -0.38691094517707825, 0.16380330920219421, -0.14440333843231201, 0.10520027577877045, -0.038494102656841278, -0.073549576103687286, 0.17539404332637787, -0.073005013167858124, -0.17232538759708405, -0.34017571806907654, -0.36681613326072693, -0.088271155953407288, -0.43714657425880432, -0.27019986510276794, -0.3900337815284729, -0.39327582716941833, 0.039167340844869614, -0.086094669997692108, -0.17719359695911407, -0.2660754919052124, -0.18057894706726074, 0.36715129017829895, 0.051057934761047363, 0.077075265347957611, -0.020483337342739105, -0.27157187461853027, -0.17937904596328735, 
  0.30289265513420105, -0.28261774778366089, -0.18145376443862915, 0.064042270183563232, 0.022220611572265625, -0.199332594871521, -0.15001213550567627, 0.11293461918830872, 0.1565321683883667, 0.10976660251617432, 0.32121571898460388, -0.33176574110984802, -0.28687620162963867, 0.32186922430992126, -0.32813182473182678, -0.12955103814601898, -0.29616385698318481, 0.043020069599151611, 0.18729236721992493, -0.26462668180465698, 0.27956584095954895, 0.32258161902427673, -0.16936714947223663, 0.24064454436302185, -0.31445541977882385, -0.19857588410377502, -0.049612939357757568, -0.27511438727378845, 0.26084324717521667, -0.093430712819099426, 0.33443567156791687, -0.18181756138801575, -0.15315704047679901, 
  -0.013877187855541706, 0.26792916655540466, -0.26130282878875732, -0.32186806201934814, -0.32414764165878296, 0.080731131136417389, -0.050844449549913406, 0.049592334777116776, 0.11723308265209198, 0.10180800408124924, -0.02851254865527153, 0.11316248774528503, -0.20247873663902283, 0.14100930094718933, 0.14202626049518585, 0.24356731772422791, 0.044683065265417099, 0.13734540343284607, 0.10706828534603119, 0.18359476327896118, -0.3218390941619873, 0.2648175060749054, -0.288286954164505, 0.13037173449993134, 0.060886859893798828, -0.0084415804594755173, -0.16034334897994995, -0.13054960966110229, -0.075299397110939026, -0.19638027250766754, 0.072487272322177887, -0.13203421235084534, -0.13678695261478424, 
  -0.13666193187236786, -0.12025880813598633, -0.27262657880783081, -0.0073363152332603931, 0.21259403228759766, -0.13041698932647705, -0.13454687595367432, -0.44233807921409607, 0.015368048101663589, -0.32587248086929321, -0.42417654395103455, -0.15135709941387177, 0.041530698537826538, 0.1184312179684639, -0.099697284400463104, 0.14116615056991577, -0.26906067132949829, -0.13744731247425079, 0.034850645810365677, -0.1722819060087204, -0.33154046535491943, -0.22023266553878784, 0.18691796064376831, -0.091328032314777374, 0.16343899071216583, -0.034114085137844086, -0.0018244546372443438, 0.33787378668785095, -0.11299563944339752, 0.28705447912216187, 0.089969925582408905, 0.038390755653381348, 0.32202452421188354, 
  0.1890733391046524, 0.23911280930042267, 0.5367545485496521, 0.36201855540275574, 0.42618423700332642, 0.02993655763566494, -0.077706299722194672, 0.65673106908798218, 0.24467484652996063, 0.14852495491504669, 0.052549406886100769, 0.16886645555496216, 0.079940713942050934, 0.05170883983373642, -0.10861626267433167, -0.075360596179962158, -0.16621151566505432, 0.1109994649887085, 0.11875293403863907, -0.42040789127349854, -0.057657729834318161, -0.27431654930114746, -0.15350615978240967, 0.42765289545059204, -0.19049295783042908, -0.082116641104221344, -0.09161580353975296, 0.17074355483055115, 0.044838897883892059, -0.087655350565910339, -0.27803316712379456, -0.30699107050895691, 0.057962782680988312, 
  -0.28129726648330688, -0.085556089878082275, 0.17763999104499817, -0.32631230354309082, 0.16132086515426636, 0.028288155794143677, -0.21756607294082642, -0.031541585922241211, -0.0094973146915435791, -0.11755266785621643, -0.30890315771102905, -0.12795829772949219, -0.28568470478057861, -0.23661193251609802, -0.2495000958442688, -0.17441542446613312, 0.021156340837478638, -0.19760523736476898, -0.18285568058490753, 0.12811866402626038, -0.16628201305866241, 0.27694216370582581, -0.18207786977291107, 0.26282402873039246, -0.1450062096118927, -0.29138362407684326, -0.013195723295211792, -0.095218867063522339, -0.29840752482414246, -0.23133769631385803, 0.15432053804397583, -0.14481297135353088, -0.21203513443470001, 
  -0.24410715699195862, 0.36955234408378601, -0.21128237247467041, -0.08241589367389679, -0.074654340744018555, -0.091723173856735229, 0.19087830185890198, -0.4060942530632019, 0.085455678403377533, 0.068620413541793823, -0.40270641446113586, 0.47602197527885437, 0.36472553014755249, 0.21204735338687897, 0.13306185603141785, 0.052888240665197372, 0.10553959757089615, -0.14626148343086243, -0.16369165480136871, 0.23629242181777954, 0.14624494314193726, -0.094314403831958771, 0.40486332774162292, -0.096651591360569, 0.16001705825328827, 0.033217035233974457, -0.032721836119890213, -0.050770934671163559, 0.29089412093162537, 0.31918948888778687, -0.0062201251275837421, 0.25272738933563232, 0.43344232439994812, 
};
const TfArray<2, int> tensor_dimension4 = { 2, { 20,33 } };
const ALIGN(16) float tensor_data5[10*20] = { 
  0.13260559737682343, -0.31265830993652344, -0.27588871121406555, 0.023728502914309502, 0.36245200037956238, 0.05985337495803833, 0.43442118167877197, -0.41827419400215149, -0.038332995027303696, -0.19483354687690735, 0.071278005838394165, 0.054355274885892868, 0.24257105588912964, 0.43536907434463501, 0.20777857303619385, -0.31586644053459167, 0.00019213557243347168, -0.11937794834375381, -0.26989120244979858, 0.077410377562046051, 
  -0.21513541042804718, -0.43652644753456116, 0.25989925861358643, 0.25670373439788818, 0.20556908845901489, -0.15646842122077942, -0.19914223253726959, -0.36983609199523926, -0.35554879903793335, 0.069873809814453125, -0.20073221623897552, -0.2023371160030365, 0.2409820556640625, 0.084498703479766846, 0.26755255460739136, 0.3430597186088562, -0.19190970063209534, 0.13136303424835205, -0.1693665087223053, -0.11774033308029175, 
  -0.11518640071153641, -0.35117670893669128, 0.12712348997592926, 0.48910284042358398, -0.29407373070716858, -0.20430496335029602, -0.13167080283164978, 0.16352526843547821, -0.11041957139968872, -0.16009262204170227, 0.23497085273265839, 0.27942189574241638, -0.081969767808914185, -0.4117150604724884, -0.050489902496337891, -0.2583014965057373, 0.29460951685905457, -0.33943825960159302, -0.38322222232818604, -0.19573329389095306, 
  0.10336434096097946, 0.072280958294868469, 0.48690313100814819, 0.10692014545202255, -0.43424561619758606, 0.32689547538757324, -0.20454667508602142, -0.1603027731180191, -0.062754958868026733, 0.38382884860038757, 0.25231695175170898, 0.25430336594581604, -0.28030186891555786, -0.51011675596237183, -0.016391962766647339, -0.16194702684879303, -0.090125277638435364, -0.43845820426940918, 0.40465575456619263, 0.56114983558654785, 
  -0.039382144808769226, 0.22110050916671753, -0.42522904276847839, -0.21522919833660126, -0.32401275634765625, 0.24947176873683929, -0.13856907188892365, 0.14580230414867401, -0.29388517141342163, 0.13320434093475342, 0.55856329202651978, 0.26774057745933533, -0.077009856700897217, 0.14067074656486511, 0.094670414924621582, -0.35522559285163879, -0.2531360387802124, 0.6017945408821106, 0.27800458669662476, 0.23102660477161407, 
  -0.48756882548332214, 0.45714285969734192, -0.010305043309926987, 0.4101385772228241, 0.068914592266082764, -0.40394514799118042, -0.0069195725955069065, 0.45846295356750488, -0.32520219683647156, 0.067902341485023499, 0.021005315706133842, 0.40750178694725037, -0.19458532333374023, 0.45608747005462646, -0.091879725456237793, -0.24951259791851044, 0.13540361821651459, -0.025270663201808929, -0.25955837965011597, 0.35047316551208496, 
  0.48962515592575073, 0.15200522541999817, -0.36835187673568726, -0.40235227346420288, 0.35498601198196411, 0.28250458836555481, 0.036057282239198685, -0.15864874422550201, -0.11650469154119492, -0.080327704548835754, 0.32310831546783447, 0.10524553805589676, -0.27470189332962036, -0.1226000040769577, 0.034872889518737793, -0.067359298467636108, 0.15826621651649475, 0.12745936214923859, -0.061746180057525635, -0.27621012926101685, 
  0.06812044233083725, 0.35818293690681458, 0.11557686328887939, 0.2005297988653183, 0.16486570239067078, 0.30254974961280823, 0.32442140579223633, -0.4218754768371582, 0.41454145312309265, -0.10141630470752716, -0.1647876501083374, 0.40697860717773438, 0.25406181812286377, 0.071609392762184143, -0.38276225328445435, 0.18203073740005493, 0.38356760144233704, 0.18930701911449432, 0.051685571670532227, 0.20114624500274658, 
  0.37229833006858826, 0.10727358609437943, 0.14607034623622894, 0.094638943672180176, 0.35675552487373352, 0.092687450349330902, -0.41864737868309021, -0.038582261651754379, -0.15103444457054138, -0.099141530692577362, 0.60186779499053955, 0.054783247411251068, -0.018651306629180908, -0.3867914080619812, -0.1313498318195343, 0.35779079794883728, -0.41964083909988403, 0.59180426597595215, -0.18146216869354248, -0.30891865491867065, 
  0.16685017943382263, -0.27893534302711487, 0.012520136311650276, 0.017307672649621964, 0.25436222553253174, 0.35509699583053589, -0.078580759465694427, 0.11145898699760437, 0.29785490036010742, -0.57868969440460205, -0.13823269307613373, 0.20878641307353973, -0.28586220741271973, -0.22886849939823151, 0.21444606781005859, -0.078846007585525513, -0.15580222010612488, 0.32824954390525818, 0.010248482227325439, 0.22280602157115936, 
};
const TfArray<2, int> tensor_dimension5 = { 2, { 10,20 } };
const ALIGN(16) float tensor_data6[4*10] = { 
  0.37011149525642395, 0.37228477001190186, 0.77191925048828125, -0.28056517243385315, 0.0097177699208259583, -0.54910451173782349, -0.91542375087738037, -0.1478220522403717, 0.72048747539520264, 0.41529554128646851, 
  0.35346642136573792, -0.11675214767456055, -0.64854758977890015, -0.64181870222091675, -0.77501964569091797, -0.25253570079803467, 0.005380991380661726, 0.35254672169685364, -0.46107086539268494, -0.044406071305274963, 
  -0.51629513502120972, 0.55127537250518799, -0.63890063762664795, -0.69002461433410645, 0.62372303009033203, -0.7308240532875061, 0.82114177942276001, 0.23920546472072601, 0.46169057488441467, -0.27847069501876831, 
  0.067132085561752319, -0.11847734451293945, 0.23171351850032806, 0.48168566823005676, 0.084259830415248871, -0.35650923848152161, 0.29795023798942566, -0.14462040364742279, -0.71822953224182129, -0.87319648265838623, 
};
const TfArray<2, int> tensor_dimension6 = { 2, { 4,10 } };
const TfArray<2, int> tensor_dimension7 = { 2, { 1,20 } };
const TfArray<2, int> tensor_dimension8 = { 2, { 1,10 } };
const TfArray<2, int> tensor_dimension9 = { 2, { 1,4 } };
const TfArray<2, int> tensor_dimension10 = { 2, { 1,4 } };
const TfLiteFullyConnectedParams opdata0 = { kTfLiteActRelu, kTfLiteFullyConnectedWeightsFormatDefault, false, false };
const TfArray<3, int> inputs0 = { 3, { 0,4,2 } };
const TfArray<1, int> outputs0 = { 1, { 7 } };
const TfLiteFullyConnectedParams opdata1 = { kTfLiteActRelu, kTfLiteFullyConnectedWeightsFormatDefault, false, false };
const TfArray<3, int> inputs1 = { 3, { 7,5,1 } };
const TfArray<1, int> outputs1 = { 1, { 8 } };
const TfLiteFullyConnectedParams opdata2 = { kTfLiteActNone, kTfLiteFullyConnectedWeightsFormatDefault, false, false };
const TfArray<3, int> inputs2 = { 3, { 8,6,3 } };
const TfArray<1, int> outputs2 = { 1, { 9 } };
const TfLiteSoftmaxParams opdata3 = { 1 };
const TfArray<1, int> inputs3 = { 1, { 9 } };
const TfArray<1, int> outputs3 = { 1, { 10 } };
};

TensorInfo_t tensorData[] = {
{ kTfLiteArenaRw, (int32_t*)(tensor_arena + 0), (TfLiteIntArray*)&g0::tensor_dimension0, 132, },
{ kTfLiteMmapRo, (int32_t*)g0::tensor_data1, (TfLiteIntArray*)&g0::tensor_dimension1, 40, },
{ kTfLiteMmapRo, (int32_t*)g0::tensor_data2, (TfLiteIntArray*)&g0::tensor_dimension2, 80, },
{ kTfLiteMmapRo, (int32_t*)g0::tensor_data3, (TfLiteIntArray*)&g0::tensor_dimension3, 16, },
{ kTfLiteMmapRo, (int32_t*)g0::tensor_data4, (TfLiteIntArray*)&g0::tensor_dimension4, 2640, },
{ kTfLiteMmapRo, (int32_t*)g0::tensor_data5, (TfLiteIntArray*)&g0::tensor_dimension5, 800, },
{ kTfLiteMmapRo, (int32_t*)g0::tensor_data6, (TfLiteIntArray*)&g0::tensor_dimension6, 160, },
{ kTfLiteArenaRw, (int32_t*)(tensor_arena + 144), (TfLiteIntArray*)&g0::tensor_dimension7, 80, },
{ kTfLiteArenaRw, (int32_t*)(tensor_arena + 0), (TfLiteIntArray*)&g0::tensor_dimension8, 40, },
{ kTfLiteArenaRw, (int32_t*)(tensor_arena + 48), (TfLiteIntArray*)&g0::tensor_dimension9, 16, },
{ kTfLiteArenaRw, (int32_t*)(tensor_arena + 0), (TfLiteIntArray*)&g0::tensor_dimension10, 16, },
};

#ifndef TF_LITE_STATIC_MEMORY
TfLiteNode tflNodes[4] = {
{ (TfLiteIntArray*)&g0::inputs0, (TfLiteIntArray*)&g0::outputs0, (TfLiteIntArray*)&g0::inputs0, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata0)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs1, (TfLiteIntArray*)&g0::outputs1, (TfLiteIntArray*)&g0::inputs1, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata1)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs2, (TfLiteIntArray*)&g0::outputs2, (TfLiteIntArray*)&g0::inputs2, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata2)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs3, (TfLiteIntArray*)&g0::outputs3, (TfLiteIntArray*)&g0::inputs3, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata3)), nullptr, 0, },
};
#else
TfLiteNode tflNodes[4] = {
{ (TfLiteIntArray*)&g0::inputs0, (TfLiteIntArray*)&g0::outputs0, (TfLiteIntArray*)&g0::inputs0, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata0)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs1, (TfLiteIntArray*)&g0::outputs1, (TfLiteIntArray*)&g0::inputs1, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata1)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs2, (TfLiteIntArray*)&g0::outputs2, (TfLiteIntArray*)&g0::inputs2, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata2)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs3, (TfLiteIntArray*)&g0::outputs3, (TfLiteIntArray*)&g0::inputs3, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata3)), nullptr, 0, },
};
#endif

used_operators_e used_ops[] =
{OP_FULLY_CONNECTED, OP_FULLY_CONNECTED, OP_FULLY_CONNECTED, OP_SOFTMAX, };


// Indices into tflTensors and tflNodes for subgraphs
const size_t tflTensors_subgraph_index[] = {0, 11, };
const size_t tflNodes_subgraph_index[] = {0, 4, };

// Input/output tensors
static const int in_tensor_indices[] = {
  0, 
};

static const int out_tensor_indices[] = {
  10, 
};


size_t current_subgraph_index = 0;

static void init_tflite_tensor(size_t i, TfLiteTensor *tensor) {
  tensor->type = kTfLiteFloat32;
  tensor->is_variable = false;

#if defined(EI_CLASSIFIER_ALLOCATION_HEAP)
  tensor->allocation_type = tensorData[i].allocation_type;
#else
  tensor->allocation_type = (tensor_arena <= tensorData[i].data && tensorData[i].data < tensor_arena + kTensorArenaSize) ? kTfLiteArenaRw : kTfLiteMmapRo;
#endif
  tensor->bytes = tensorData[i].bytes;
  tensor->dims = tensorData[i].dims;

#if defined(EI_CLASSIFIER_ALLOCATION_HEAP)
  if(tensor->allocation_type == kTfLiteArenaRw){
    uint8_t* start = (uint8_t*) ((uintptr_t)tensorData[i].data + (uintptr_t) tensor_arena);

    tensor->data.data =  start;
  }
  else {
      tensor->data.data = tensorData[i].data;
  }
#else
  tensor->data.data = tensorData[i].data;
#endif // EI_CLASSIFIER_ALLOCATION_HEAP
  tensor->quantization.type = kTfLiteNoQuantization;

}

static void init_tflite_eval_tensor(int i, TfLiteEvalTensor *tensor) {

  tensor->type = kTfLiteFloat32;

  tensor->dims = tensorData[i].dims;

#if defined(EI_CLASSIFIER_ALLOCATION_HEAP)
  auto allocation_type = tensorData[i].allocation_type;
  if(allocation_type == kTfLiteArenaRw) {
    uint8_t* start = (uint8_t*) ((uintptr_t)tensorData[i].data + (uintptr_t) tensor_arena);

    tensor->data.data =  start;
  }
  else {
    tensor->data.data = tensorData[i].data;
  }
#else
  tensor->data.data = tensorData[i].data;
#endif // EI_CLASSIFIER_ALLOCATION_HEAP
}

static void* overflow_buffers[EI_MAX_OVERFLOW_BUFFER_COUNT];
static size_t overflow_buffers_ix = 0;
static void * AllocatePersistentBufferImpl(struct TfLiteContext* ctx,
                                       size_t bytes) {
  void *ptr;
  uint32_t align_bytes = (bytes % 16) ? 16 - (bytes % 16) : 0;

  if (current_location - (bytes + align_bytes) < tensor_boundary) {
    if (overflow_buffers_ix > EI_MAX_OVERFLOW_BUFFER_COUNT - 1) {
      ei_printf("ERR: Failed to allocate persistent buffer of size %d, does not fit in tensor arena and reached EI_MAX_OVERFLOW_BUFFER_COUNT\n",
        (int)bytes);
      return NULL;
    }

    // OK, this will look super weird, but.... we have CMSIS-NN buffers which
    // we cannot calculate beforehand easily.
    ptr = ei_calloc(bytes, 1);
    if (ptr == NULL) {
      ei_printf("ERR: Failed to allocate persistent buffer of size %d\n", (int)bytes);
      return NULL;
    }
    overflow_buffers[overflow_buffers_ix++] = ptr;
    return ptr;
  }

  current_location -= bytes;

  // align to the left aligned boundary of 16 bytes
  current_location -= 15; // for alignment
  current_location += 16 - ((uintptr_t)(current_location) & 15);

  ptr = current_location;
  memset(ptr, 0, bytes);

  return ptr;
}

typedef struct {
  size_t bytes;
  void *ptr;
} scratch_buffer_t;

static scratch_buffer_t scratch_buffers[EI_MAX_SCRATCH_BUFFER_COUNT];
static size_t scratch_buffers_ix = 0;

static TfLiteStatus RequestScratchBufferInArenaImpl(struct TfLiteContext* ctx, size_t bytes,
                                                int* buffer_idx) {
  if (scratch_buffers_ix > EI_MAX_SCRATCH_BUFFER_COUNT - 1) {
    ei_printf("ERR: Failed to allocate scratch buffer of size %d, reached EI_MAX_SCRATCH_BUFFER_COUNT\n",
      (int)bytes);
    return kTfLiteError;
  }

  scratch_buffer_t b;
  b.bytes = bytes;

  b.ptr = AllocatePersistentBufferImpl(ctx, b.bytes);
  if (!b.ptr) {
    ei_printf("ERR: Failed to allocate scratch buffer of size %d\n",
      (int)bytes);
    return kTfLiteError;
  }

  scratch_buffers[scratch_buffers_ix] = b;
  *buffer_idx = scratch_buffers_ix;

  scratch_buffers_ix++;

  return kTfLiteOk;
}

static void* GetScratchBufferImpl(struct TfLiteContext* ctx, int buffer_idx) {
  if (buffer_idx > (int)scratch_buffers_ix) {
    return NULL;
  }
  return scratch_buffers[buffer_idx].ptr;
}

static const uint16_t TENSOR_IX_UNUSED = 0x7FFF;

static void ResetTensors() {
  for (size_t ix = 0; ix < MAX_TFL_TENSOR_COUNT; ix++) {
    tflTensors[ix].index = TENSOR_IX_UNUSED;
  }
  for (size_t ix = 0; ix < MAX_TFL_EVAL_COUNT; ix++) {
    tflEvalTensors[ix].index = TENSOR_IX_UNUSED;
  }
}

static TfLiteTensor* GetTensorImpl(const struct TfLiteContext* context,
                               int tensor_idx) {

  tensor_idx = tflTensors_subgraph_index[current_subgraph_index] + tensor_idx;

  for (size_t ix = 0; ix < MAX_TFL_TENSOR_COUNT; ix++) {
    // already used? OK!
    if (tflTensors[ix].index == tensor_idx) {
      return &tflTensors[ix].tensor;
    }
    // passed all the ones we've used, so end of the list?
    if (tflTensors[ix].index == TENSOR_IX_UNUSED) {
      // init the tensor
      init_tflite_tensor(tensor_idx, &tflTensors[ix].tensor);
      tflTensors[ix].index = tensor_idx;
      return &tflTensors[ix].tensor;
    }
  }

  ei_printf("ERR: GetTensor called beyond MAX_TFL_TENSOR_COUNT (%d)\n", MAX_TFL_TENSOR_COUNT);
  return nullptr;
}

static TfLiteEvalTensor* GetEvalTensorImpl(const struct TfLiteContext* context,
                                       int tensor_idx) {

  tensor_idx = tflTensors_subgraph_index[current_subgraph_index] + tensor_idx;

  for (size_t ix = 0; ix < MAX_TFL_EVAL_COUNT; ix++) {
    // already used? OK!
    if (tflEvalTensors[ix].index == tensor_idx) {
      return &tflEvalTensors[ix].tensor;
    }
    // passed all the ones we've used, so end of the list?
    if (tflEvalTensors[ix].index == TENSOR_IX_UNUSED) {
      // init the tensor
      init_tflite_eval_tensor(tensor_idx, &tflEvalTensors[ix].tensor);
      tflEvalTensors[ix].index = tensor_idx;
      return &tflEvalTensors[ix].tensor;
    }
  }

  ei_printf("ERR: GetTensor called beyond MAX_TFL_EVAL_COUNT (%d)\n", (int)MAX_TFL_EVAL_COUNT);
  return nullptr;
}

class EonMicroContext : public MicroContext {
 public:
 
  EonMicroContext(): MicroContext(nullptr, nullptr, nullptr) { }

  void* AllocatePersistentBuffer(size_t bytes) {
    return AllocatePersistentBufferImpl(nullptr, bytes);
  }

  TfLiteStatus RequestScratchBufferInArena(size_t bytes,
                                           int* buffer_index) {
  return RequestScratchBufferInArenaImpl(nullptr, bytes, buffer_index);
  }

  void* GetScratchBuffer(int buffer_index) {
    return GetScratchBufferImpl(nullptr, buffer_index);
  }
 
  TfLiteTensor* AllocateTempTfLiteTensor(int tensor_index) {
    return GetTensorImpl(nullptr, tensor_index);
  }

  void DeallocateTempTfLiteTensor(TfLiteTensor* tensor) {
    return;
  }

  bool IsAllTempTfLiteTensorDeallocated() {
    return true;
  }

  TfLiteEvalTensor* GetEvalTensor(int tensor_index) {
    return GetEvalTensorImpl(nullptr, tensor_index);
  }

};


} // namespace

TfLiteStatus tflite_learn_7_init( void*(*alloc_fnc)(size_t,size_t) ) {
#ifdef EI_CLASSIFIER_ALLOCATION_HEAP
  tensor_arena = (uint8_t*) alloc_fnc(16, kTensorArenaSize);
  if (!tensor_arena) {
    ei_printf("ERR: failed to allocate tensor arena\n");
    return kTfLiteError;
  }
#else
  memset(tensor_arena, 0, kTensorArenaSize);
#endif
  tensor_boundary = tensor_arena;
  current_location = tensor_arena + kTensorArenaSize;

  EonMicroContext micro_context_;
  
  // Set microcontext as the context ptr
  ctx.impl_ = static_cast<void*>(&micro_context_);
  // Setup tflitecontext functions
  ctx.AllocatePersistentBuffer = &AllocatePersistentBufferImpl;
  ctx.RequestScratchBufferInArena = &RequestScratchBufferInArenaImpl;
  ctx.GetScratchBuffer = &GetScratchBufferImpl;
  ctx.GetTensor = &GetTensorImpl;
  ctx.GetEvalTensor = &GetEvalTensorImpl;
  ctx.ReportError = &MicroContextReportOpError;

  ctx.tensors_size = 11;
  for (size_t i = 0; i < 11; ++i) {
    TfLiteTensor tensor;
    init_tflite_tensor(i, &tensor);
    if (tensor.allocation_type == kTfLiteArenaRw) {
      auto data_end_ptr = (uint8_t*)tensor.data.data + tensorData[i].bytes;
      if (data_end_ptr > tensor_boundary) {
        tensor_boundary = data_end_ptr;
      }
    }
  }

  if (tensor_boundary > current_location /* end of arena size */) {
    ei_printf("ERR: tensor arena is too small, does not fit model - even without scratch buffers\n");
    return kTfLiteError;
  }

  registrations[OP_FULLY_CONNECTED] = Register_FULLY_CONNECTED();
  registrations[OP_SOFTMAX] = Register_SOFTMAX();

  for (size_t g = 0; g < 1; ++g) {
    current_subgraph_index = g;
    for(size_t i = tflNodes_subgraph_index[g]; i < tflNodes_subgraph_index[g+1]; ++i) {
      if (registrations[used_ops[i]].init) {
        tflNodes[i].user_data = registrations[used_ops[i]].init(&ctx, (const char*)tflNodes[i].builtin_data, 0);
      }
    }
  }
  current_subgraph_index = 0;

  for(size_t g = 0; g < 1; ++g) {
    current_subgraph_index = g;
    for(size_t i = tflNodes_subgraph_index[g]; i < tflNodes_subgraph_index[g+1]; ++i) {
      if (registrations[used_ops[i]].prepare) {
        ResetTensors();
        TfLiteStatus status = registrations[used_ops[i]].prepare(&ctx, &tflNodes[i]);
        if (status != kTfLiteOk) {
          return status;
        }
      }
    }
  }
  current_subgraph_index = 0;

  return kTfLiteOk;
}

TfLiteStatus tflite_learn_7_input(int index, TfLiteTensor *tensor) {
  init_tflite_tensor(in_tensor_indices[index], tensor);
  return kTfLiteOk;
}

TfLiteStatus tflite_learn_7_output(int index, TfLiteTensor *tensor) {
  init_tflite_tensor(out_tensor_indices[index], tensor);
  return kTfLiteOk;
}

TfLiteStatus tflite_learn_7_invoke() {
  for (size_t i = 0; i < 4; ++i) {
    ResetTensors();

    TfLiteStatus status = registrations[used_ops[i]].invoke(&ctx, &tflNodes[i]);

#if EI_CLASSIFIER_PRINT_STATE
    ei_printf("layer %lu\n", i);
    ei_printf("    inputs:\n");
    for (size_t ix = 0; ix < tflNodes[i].inputs->size; ix++) {
      auto d = tensorData[tflNodes[i].inputs->data[ix]];

      size_t data_ptr = (size_t)d.data;

      if (d.allocation_type == kTfLiteArenaRw) {
        data_ptr = (size_t)tensor_arena + data_ptr;
      }

      if (d.type == TfLiteType::kTfLiteInt8) {
        int8_t* data = (int8_t*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes; jx++) {
          ei_printf("%d ", data[jx]);
        }
      }
      else {
        float* data = (float*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes / 4; jx++) {
          ei_printf("%f ", data[jx]);
        }
      }
      ei_printf("\n");
    }
    ei_printf("\n");

    ei_printf("    outputs:\n");
    for (size_t ix = 0; ix < tflNodes[i].outputs->size; ix++) {
      auto d = tensorData[tflNodes[i].outputs->data[ix]];

      size_t data_ptr = (size_t)d.data;

      if (d.allocation_type == kTfLiteArenaRw) {
        data_ptr = (size_t)tensor_arena + data_ptr;
      }

      if (d.type == TfLiteType::kTfLiteInt8) {
        int8_t* data = (int8_t*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes; jx++) {
          ei_printf("%d ", data[jx]);
        }
      }
      else {
        float* data = (float*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes / 4; jx++) {
          ei_printf("%f ", data[jx]);
        }
      }
      ei_printf("\n");
    }
    ei_printf("\n");
#endif // EI_CLASSIFIER_PRINT_STATE

    if (status != kTfLiteOk) {
      return status;
    }
  }
  return kTfLiteOk;
}

TfLiteStatus tflite_learn_7_reset( void (*free_fnc)(void* ptr) ) {
#ifdef EI_CLASSIFIER_ALLOCATION_HEAP
  free_fnc(tensor_arena);
#endif

  // scratch buffers are allocated within the arena, so just reset the counter so memory can be reused
  scratch_buffers_ix = 0;

  // overflow buffers are on the heap, so free them first
  for (size_t ix = 0; ix < overflow_buffers_ix; ix++) {
    ei_free(overflow_buffers[ix]);
  }
  overflow_buffers_ix = 0;
  return kTfLiteOk;
}
